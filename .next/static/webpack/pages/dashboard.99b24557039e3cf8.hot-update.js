"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard",{

/***/ "./components/InstagramCarousel.js":
/*!*****************************************!*\
  !*** ./components/InstagramCarousel.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ InstagramCarousel; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction InstagramCarousel(param) {\n    let { images, currentIndex = 0, onIndexChange, post } = param;\n    _s();\n    const [index, setIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(currentIndex);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dragOffset, setDragOffset] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [startX, setStartX] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [startTime, setStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [velocityX, setVelocityX] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastTouchTime = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const lastTouchX = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Physics constants for smooth animations\n    const SNAP_THRESHOLD = 0.3 // 30% of container width\n    ;\n    const VELOCITY_THRESHOLD = 0.5 // minimum velocity for momentum\n    ;\n    const FRICTION = 0.85 // deceleration factor\n    ;\n    const SPRING_DAMPING = 0.8;\n    const SPRING_STIFFNESS = 0.3;\n    // Update internal index when prop changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setIndex(currentIndex);\n    }, [\n        currentIndex\n    ]);\n    // Smooth animation using RAF\n    const animateToIndex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(targetIndex) {\n        let initialVelocity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        var _containerRef_current;\n        if (animationRef.current) {\n            cancelAnimationFrame(animationRef.current);\n        }\n        const containerWidth = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || window.innerWidth;\n        const targetOffset = -targetIndex * containerWidth;\n        let currentOffset = dragOffset;\n        let velocity = initialVelocity;\n        const animate = ()=>{\n            const distance = targetOffset - currentOffset;\n            const springForce = distance * SPRING_STIFFNESS;\n            velocity = (velocity + springForce) * SPRING_DAMPING;\n            currentOffset += velocity;\n            setDragOffset(currentOffset);\n            // Continue animation if we haven't reached the target\n            if (Math.abs(distance) > 1 || Math.abs(velocity) > 0.1) {\n                animationRef.current = requestAnimationFrame(animate);\n            } else {\n                setDragOffset(targetOffset);\n                setIsDragging(false);\n            }\n        };\n        animate();\n    }, [\n        dragOffset\n    ]);\n    // Handle navigation with bounds checking\n    const navigateToIndex = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(newIndex) {\n        let velocity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const clampedIndex = Math.max(0, Math.min(images.length - 1, newIndex));\n        setIndex(clampedIndex);\n        onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(clampedIndex);\n        animateToIndex(clampedIndex, velocity);\n    }, [\n        images.length,\n        onIndexChange,\n        animateToIndex\n    ]);\n    // Touch event handlers optimized for mobile\n    const handleTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        const touch = e.touches[0];\n        setIsDragging(true);\n        setStartX(touch.clientX);\n        setStartTime(Date.now());\n        setVelocityX(0);\n        lastTouchTime.current = Date.now();\n        lastTouchX.current = touch.clientX;\n        if (animationRef.current) {\n            cancelAnimationFrame(animationRef.current);\n        }\n        // Prevent default only for horizontal movements\n        e.stopPropagation();\n    }, []);\n    const handleTouchMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _containerRef_current;\n        if (!isDragging) return;\n        const touch = e.touches[0];\n        const currentTime = Date.now();\n        const deltaTime = currentTime - lastTouchTime.current;\n        const deltaX = touch.clientX - lastTouchX.current;\n        const deltaY = Math.abs(touch.clientY - e.touches[0].clientY);\n        // Only prevent default if horizontal movement is dominant\n        const rawOffsetX = Math.abs(touch.clientX - startX);\n        if (rawOffsetX > 10) {\n            e.preventDefault();\n        }\n        // Calculate velocity for momentum\n        if (deltaTime > 0) {\n            setVelocityX(deltaX / deltaTime);\n        }\n        const containerWidth = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || window.innerWidth;\n        const rawOffset = touch.clientX - startX;\n        // Add resistance at boundaries (rubber band effect)\n        let offset = rawOffset;\n        const currentTargetOffset = -index * containerWidth;\n        // Apply resistance if dragging beyond boundaries\n        if (index === 0 && offset > 0) {\n            offset = offset * 0.2 // More resistance when at first image\n            ;\n        } else if (index === images.length - 1 && offset < 0) {\n            offset = offset * 0.2 // More resistance when at last image\n            ;\n        }\n        setDragOffset(currentTargetOffset + offset);\n        lastTouchTime.current = currentTime;\n        lastTouchX.current = touch.clientX;\n    }, [\n        isDragging,\n        startX,\n        index,\n        images.length\n    ]);\n    const handleTouchEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _containerRef_current;\n        if (!isDragging) return;\n        const containerWidth = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || window.innerWidth;\n        const deltaX = dragOffset + index * containerWidth;\n        const deltaTime = Date.now() - startTime;\n        const absVelocity = Math.abs(velocityX);\n        setIsDragging(false);\n        // Determine if we should change slides\n        let newIndex = index;\n        // Use velocity for quick swipes (more sensitive on mobile)\n        if (absVelocity > 0.3) {\n            if (velocityX < -0.3 && index < images.length - 1) {\n                newIndex = index + 1;\n            } else if (velocityX > 0.3 && index > 0) {\n                newIndex = index - 1;\n            }\n        } else if (Math.abs(deltaX) > containerWidth * 0.2) {\n            if (deltaX < 0 && index < images.length - 1) {\n                newIndex = index + 1;\n            } else if (deltaX > 0 && index > 0) {\n                newIndex = index - 1;\n            }\n        }\n        // Apply momentum for smooth deceleration\n        const momentum = velocityX * 50 // Reduced momentum for mobile\n        ;\n        navigateToIndex(newIndex, momentum);\n    }, [\n        isDragging,\n        dragOffset,\n        index,\n        startTime,\n        velocityX,\n        images.length,\n        navigateToIndex\n    ]);\n    // Mouse events for desktop testing\n    const handleMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        e.preventDefault();\n        setIsDragging(true);\n        setStartX(e.clientX);\n        setStartTime(Date.now());\n    }, []);\n    const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _containerRef_current;\n        if (!isDragging) return;\n        e.preventDefault();\n        const containerWidth = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || window.innerWidth;\n        const offset = e.clientX - startX;\n        const currentTargetOffset = -index * containerWidth;\n        setDragOffset(currentTargetOffset + offset);\n    }, [\n        isDragging,\n        startX,\n        index\n    ]);\n    const handleMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _containerRef_current;\n        if (!isDragging) return;\n        e.preventDefault();\n        const containerWidth = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || window.innerWidth;\n        const deltaX = dragOffset + index * containerWidth;\n        setIsDragging(false);\n        let newIndex = index;\n        if (Math.abs(deltaX) > containerWidth * SNAP_THRESHOLD) {\n            if (deltaX < 0 && index < images.length - 1) {\n                newIndex = index + 1;\n            } else if (deltaX > 0 && index > 0) {\n                newIndex = index - 1;\n            }\n        }\n        navigateToIndex(newIndex);\n    }, [\n        isDragging,\n        dragOffset,\n        index,\n        images.length,\n        navigateToIndex\n    ]);\n    // Cleanup animation on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, []);\n    // Calculate transform with hardware acceleration\n    const transform = \"translate3d(\".concat(dragOffset, \"px, 0, 0)\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            position: \"relative\",\n            overflow: \"hidden\",\n            cursor: isDragging ? \"grabbing\" : \"grab\",\n            touchAction: \"pan-y\",\n            WebkitUserSelect: \"none\",\n            userSelect: \"none\"\n        },\n        onTouchStart: handleTouchStart,\n        onTouchMove: handleTouchMove,\n        onTouchEnd: handleTouchEnd,\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"flex\",\n                    width: \"\".concat(images.length * 100, \"%\"),\n                    height: \"100%\",\n                    transform,\n                    transition: isDragging ? \"none\" : \"transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\n                    willChange: \"transform\",\n                    backfaceVisibility: \"hidden\"\n                },\n                children: images.map((url, imgIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            width: \"\".concat(100 / images.length, \"%\"),\n                            height: \"100%\",\n                            flexShrink: 0,\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            justifyContent: \"center\",\n                            overflow: \"hidden\"\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: url,\n                            alt: \"\".concat((post === null || post === void 0 ? void 0 : post.title) || \"Post\", \" - \").concat(imgIndex + 1, \"/\").concat(images.length),\n                            style: {\n                                maxWidth: \"100%\",\n                                maxHeight: \"100%\",\n                                objectFit: \"contain\",\n                                transform: \"translateZ(0)\",\n                                backfaceVisibility: \"hidden\",\n                                // Subtle parallax effect during drag\n                                ...isDragging && imgIndex !== index && {\n                                    filter: \"brightness(0.8)\",\n                                    transform: \"translateZ(0) scale(0.95)\"\n                                }\n                            },\n                            onDragStart: (e)=>e.preventDefault()\n                        }, void 0, false, {\n                            fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n                            lineNumber: 256,\n                            columnNumber: 13\n                        }, this)\n                    }, imgIndex, false, {\n                        fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n                        lineNumber: 244,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n                lineNumber: 232,\n                columnNumber: 7\n            }, this),\n            images.length > 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    bottom: \"20px\",\n                    left: \"50%\",\n                    transform: \"translateX(-50%)\",\n                    display: \"flex\",\n                    gap: \"3px\",\n                    zIndex: 20\n                },\n                children: images.map((_, dotIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: (e)=>{\n                            e.stopPropagation();\n                            navigateToIndex(dotIndex);\n                        },\n                        style: {\n                            width: \"2px\",\n                            height: \"2px\",\n                            borderRadius: \"50%\",\n                            border: \"none\",\n                            background: dotIndex === index ? \"white\" : \"rgba(255, 255, 255, 0.3)\",\n                            cursor: \"pointer\",\n                            transition: \"all 0.2s ease-out\",\n                            transform: dotIndex === index ? \"scale(1.5)\" : \"scale(1)\",\n                            boxShadow: dotIndex === index ? \"0 0 4px rgba(255, 255, 255, 0.5)\" : \"none\",\n                            WebkitTapHighlightColor: \"transparent\",\n                            outline: \"none\",\n                            minWidth: \"12px\",\n                            minHeight: \"12px\",\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            justifyContent: \"center\"\n                        },\n                        onMouseOver: (e)=>{\n                            if (dotIndex !== index) {\n                                e.target.style.background = \"rgba(255, 255, 255, 0.8)\";\n                                e.target.style.transform = \"scale(1.1)\";\n                            }\n                        },\n                        onMouseOut: (e)=>{\n                            if (dotIndex !== index) {\n                                e.target.style.background = \"rgba(255, 255, 255, 0.5)\";\n                                e.target.style.transform = \"scale(1)\";\n                            }\n                        }\n                    }, dotIndex, false, {\n                        fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n                        lineNumber: 289,\n                        columnNumber: 13\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n                lineNumber: 279,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/bobernagadamian/Desktop/AlbumSergiu copy 4/components/InstagramCarousel.js\",\n        lineNumber: 212,\n        columnNumber: 5\n    }, this);\n}\n_s(InstagramCarousel, \"sxEOF2+g48Pirqdg0Gv/Ms+9/q0=\");\n_c = InstagramCarousel;\nvar _c;\n$RefreshReg$(_c, \"InstagramCarousel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UkMsWUFBWUwsYUFBYWpILFFBQVEsVUFBVTs0QkFDM0M4RSxRQUFROzRCQUNSWSxZQUFZOzRCQUNacEIsV0FBVzJDLGFBQWFqSCxRQUFRLGVBQWU7NEJBQy9DdUgsV0FBV04sYUFBYWpILFFBQVEscUNBQXFDOzRCQUNyRXdILHlCQUF5Qjs0QkFDekJDLFNBQVM7NEJBQ1RDLFVBQVU7NEJBQ1ZDLFdBQVc7NEJBQ1hsQyxTQUFTOzRCQUNUUSxZQUFZOzRCQUNaQyxnQkFBZ0I7d0JBQ2xCO3dCQUNBMEIsYUFBYSxDQUFDOUU7NEJBQ1osSUFBSW1FLGFBQWFqSCxPQUFPO2dDQUN0QjhDLEVBQUUrRSxNQUFNLENBQUNwRCxLQUFLLENBQUM2QyxVQUFVLEdBQUc7Z0NBQzVCeEUsRUFBRStFLE1BQU0sQ0FBQ3BELEtBQUssQ0FBQ0gsU0FBUyxHQUFHOzRCQUM3Qjt3QkFDRjt3QkFDQXdELFlBQVksQ0FBQ2hGOzRCQUNYLElBQUltRSxhQUFhakgsT0FBTztnQ0FDdEI4QyxFQUFFK0UsTUFBTSxDQUFDcEQsS0FBSyxDQUFDNkMsVUFBVSxHQUFHO2dDQUM1QnhFLEVBQUUrRSxNQUFNLENBQUNwRCxLQUFLLENBQUNILFNBQVMsR0FBRzs0QkFDN0I7d0JBQ0Y7dUJBbENLMkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q25CO0dBeFV3QnRIO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvSW5zdGFncmFtQ2Fyb3VzZWwuanM/ZTQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluc3RhZ3JhbUNhcm91c2VsKHsgaW1hZ2VzLCBjdXJyZW50SW5kZXggPSAwLCBvbkluZGV4Q2hhbmdlLCBwb3N0IH0pIHtcbiAgY29uc3QgW2luZGV4LCBzZXRJbmRleF0gPSB1c2VTdGF0ZShjdXJyZW50SW5kZXgpXG4gIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbZHJhZ09mZnNldCwgc2V0RHJhZ09mZnNldF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBbc3RhcnRYLCBzZXRTdGFydFhdID0gdXNlU3RhdGUoMClcbiAgY29uc3QgW3N0YXJ0VGltZSwgc2V0U3RhcnRUaW1lXSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IFt2ZWxvY2l0eVgsIHNldFZlbG9jaXR5WF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbClcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmKG51bGwpXG4gIGNvbnN0IGxhc3RUb3VjaFRpbWUgPSB1c2VSZWYoMClcbiAgY29uc3QgbGFzdFRvdWNoWCA9IHVzZVJlZigwKVxuXG4gIC8vIFBoeXNpY3MgY29uc3RhbnRzIGZvciBzbW9vdGggYW5pbWF0aW9uc1xuICBjb25zdCBTTkFQX1RIUkVTSE9MRCA9IDAuMyAvLyAzMCUgb2YgY29udGFpbmVyIHdpZHRoXG4gIGNvbnN0IFZFTE9DSVRZX1RIUkVTSE9MRCA9IDAuNSAvLyBtaW5pbXVtIHZlbG9jaXR5IGZvciBtb21lbnR1bVxuICBjb25zdCBGUklDVElPTiA9IDAuODUgLy8gZGVjZWxlcmF0aW9uIGZhY3RvclxuICBjb25zdCBTUFJJTkdfREFNUElORyA9IDAuOFxuICBjb25zdCBTUFJJTkdfU1RJRkZORVNTID0gMC4zXG5cbiAgLy8gVXBkYXRlIGludGVybmFsIGluZGV4IHdoZW4gcHJvcCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SW5kZXgoY3VycmVudEluZGV4KVxuICB9LCBbY3VycmVudEluZGV4XSlcblxuICAvLyBTbW9vdGggYW5pbWF0aW9uIHVzaW5nIFJBRlxuICBjb25zdCBhbmltYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKCh0YXJnZXRJbmRleCwgaW5pdGlhbFZlbG9jaXR5ID0gMCkgPT4ge1xuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpXG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudD8ub2Zmc2V0V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGhcbiAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSAtdGFyZ2V0SW5kZXggKiBjb250YWluZXJXaWR0aFxuICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gZHJhZ09mZnNldFxuICAgIGxldCB2ZWxvY2l0eSA9IGluaXRpYWxWZWxvY2l0eVxuXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGFyZ2V0T2Zmc2V0IC0gY3VycmVudE9mZnNldFxuICAgICAgY29uc3Qgc3ByaW5nRm9yY2UgPSBkaXN0YW5jZSAqIFNQUklOR19TVElGRk5FU1NcbiAgICAgIHZlbG9jaXR5ID0gKHZlbG9jaXR5ICsgc3ByaW5nRm9yY2UpICogU1BSSU5HX0RBTVBJTkdcblxuICAgICAgY3VycmVudE9mZnNldCArPSB2ZWxvY2l0eVxuXG4gICAgICBzZXREcmFnT2Zmc2V0KGN1cnJlbnRPZmZzZXQpXG5cbiAgICAgIC8vIENvbnRpbnVlIGFuaW1hdGlvbiBpZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIHRhcmdldFxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlKSA+IDEgfHwgTWF0aC5hYnModmVsb2NpdHkpID4gMC4xKSB7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREcmFnT2Zmc2V0KHRhcmdldE9mZnNldClcbiAgICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbmltYXRlKClcbiAgfSwgW2RyYWdPZmZzZXRdKVxuXG4gIC8vIEhhbmRsZSBuYXZpZ2F0aW9uIHdpdGggYm91bmRzIGNoZWNraW5nXG4gIGNvbnN0IG5hdmlnYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKChuZXdJbmRleCwgdmVsb2NpdHkgPSAwKSA9PiB7XG4gICAgY29uc3QgY2xhbXBlZEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW1hZ2VzLmxlbmd0aCAtIDEsIG5ld0luZGV4KSlcbiAgICBzZXRJbmRleChjbGFtcGVkSW5kZXgpXG4gICAgb25JbmRleENoYW5nZT8uKGNsYW1wZWRJbmRleClcbiAgICBhbmltYXRlVG9JbmRleChjbGFtcGVkSW5kZXgsIHZlbG9jaXR5KVxuICB9LCBbaW1hZ2VzLmxlbmd0aCwgb25JbmRleENoYW5nZSwgYW5pbWF0ZVRvSW5kZXhdKVxuXG4gIC8vIFRvdWNoIGV2ZW50IGhhbmRsZXJzIG9wdGltaXplZCBmb3IgbW9iaWxlXG4gIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdXG4gICAgc2V0SXNEcmFnZ2luZyh0cnVlKVxuICAgIHNldFN0YXJ0WCh0b3VjaC5jbGllbnRYKVxuICAgIHNldFN0YXJ0VGltZShEYXRlLm5vdygpKVxuICAgIHNldFZlbG9jaXR5WCgwKVxuICAgIGxhc3RUb3VjaFRpbWUuY3VycmVudCA9IERhdGUubm93KClcbiAgICBsYXN0VG91Y2hYLmN1cnJlbnQgPSB0b3VjaC5jbGllbnRYXG5cbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KVxuICAgIH1cbiAgICBcbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgb25seSBmb3IgaG9yaXpvbnRhbCBtb3ZlbWVudHNcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZVRvdWNoTW92ZSA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm5cbiAgICBcbiAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGRlbHRhVGltZSA9IGN1cnJlbnRUaW1lIC0gbGFzdFRvdWNoVGltZS5jdXJyZW50XG4gICAgY29uc3QgZGVsdGFYID0gdG91Y2guY2xpZW50WCAtIGxhc3RUb3VjaFguY3VycmVudFxuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSBlLnRvdWNoZXNbMF0uY2xpZW50WSlcbiAgICBcbiAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBpZiBob3Jpem9udGFsIG1vdmVtZW50IGlzIGRvbWluYW50XG4gICAgY29uc3QgcmF3T2Zmc2V0WCA9IE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSBzdGFydFgpXG4gICAgaWYgKHJhd09mZnNldFggPiAxMCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHZlbG9jaXR5IGZvciBtb21lbnR1bVxuICAgIGlmIChkZWx0YVRpbWUgPiAwKSB7XG4gICAgICBzZXRWZWxvY2l0eVgoZGVsdGFYIC8gZGVsdGFUaW1lKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVmLmN1cnJlbnQ/Lm9mZnNldFdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgY29uc3QgcmF3T2Zmc2V0ID0gdG91Y2guY2xpZW50WCAtIHN0YXJ0WFxuICAgIFxuICAgIC8vIEFkZCByZXNpc3RhbmNlIGF0IGJvdW5kYXJpZXMgKHJ1YmJlciBiYW5kIGVmZmVjdClcbiAgICBsZXQgb2Zmc2V0ID0gcmF3T2Zmc2V0XG4gICAgY29uc3QgY3VycmVudFRhcmdldE9mZnNldCA9IC1pbmRleCAqIGNvbnRhaW5lcldpZHRoXG5cbiAgICAvLyBBcHBseSByZXNpc3RhbmNlIGlmIGRyYWdnaW5nIGJleW9uZCBib3VuZGFyaWVzXG4gICAgaWYgKGluZGV4ID09PSAwICYmIG9mZnNldCA+IDApIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCAqIDAuMiAvLyBNb3JlIHJlc2lzdGFuY2Ugd2hlbiBhdCBmaXJzdCBpbWFnZVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGltYWdlcy5sZW5ndGggLSAxICYmIG9mZnNldCA8IDApIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCAqIDAuMiAvLyBNb3JlIHJlc2lzdGFuY2Ugd2hlbiBhdCBsYXN0IGltYWdlXG4gICAgfVxuXG4gICAgc2V0RHJhZ09mZnNldChjdXJyZW50VGFyZ2V0T2Zmc2V0ICsgb2Zmc2V0KVxuICAgIGxhc3RUb3VjaFRpbWUuY3VycmVudCA9IGN1cnJlbnRUaW1lXG4gICAgbGFzdFRvdWNoWC5jdXJyZW50ID0gdG91Y2guY2xpZW50WFxuICB9LCBbaXNEcmFnZ2luZywgc3RhcnRYLCBpbmRleCwgaW1hZ2VzLmxlbmd0aF0pXG5cbiAgY29uc3QgaGFuZGxlVG91Y2hFbmQgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuXG4gICAgXG4gICAgY29uc3QgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudD8ub2Zmc2V0V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGhcbiAgICBjb25zdCBkZWx0YVggPSBkcmFnT2Zmc2V0ICsgKGluZGV4ICogY29udGFpbmVyV2lkdGgpXG4gICAgY29uc3QgZGVsdGFUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgIGNvbnN0IGFic1ZlbG9jaXR5ID0gTWF0aC5hYnModmVsb2NpdHlYKVxuXG4gICAgc2V0SXNEcmFnZ2luZyhmYWxzZSlcblxuICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgY2hhbmdlIHNsaWRlc1xuICAgIGxldCBuZXdJbmRleCA9IGluZGV4XG4gICAgXG4gICAgLy8gVXNlIHZlbG9jaXR5IGZvciBxdWljayBzd2lwZXMgKG1vcmUgc2Vuc2l0aXZlIG9uIG1vYmlsZSlcbiAgICBpZiAoYWJzVmVsb2NpdHkgPiAwLjMpIHtcbiAgICAgIGlmICh2ZWxvY2l0eVggPCAtMC4zICYmIGluZGV4IDwgaW1hZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV3SW5kZXggPSBpbmRleCArIDFcbiAgICAgIH0gZWxzZSBpZiAodmVsb2NpdHlYID4gMC4zICYmIGluZGV4ID4gMCkge1xuICAgICAgICBuZXdJbmRleCA9IGluZGV4IC0gMVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgZGlzdGFuY2UgZm9yIHNsb3cgZHJhZ3MgKGxvd2VyIHRocmVzaG9sZClcbiAgICBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVgpID4gY29udGFpbmVyV2lkdGggKiAwLjIpIHtcbiAgICAgIGlmIChkZWx0YVggPCAwICYmIGluZGV4IDwgaW1hZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV3SW5kZXggPSBpbmRleCArIDFcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGFYID4gMCAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgbmV3SW5kZXggPSBpbmRleCAtIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBtb21lbnR1bSBmb3Igc21vb3RoIGRlY2VsZXJhdGlvblxuICAgIGNvbnN0IG1vbWVudHVtID0gdmVsb2NpdHlYICogNTAgLy8gUmVkdWNlZCBtb21lbnR1bSBmb3IgbW9iaWxlXG4gICAgbmF2aWdhdGVUb0luZGV4KG5ld0luZGV4LCBtb21lbnR1bSlcbiAgfSwgW2lzRHJhZ2dpbmcsIGRyYWdPZmZzZXQsIGluZGV4LCBzdGFydFRpbWUsIHZlbG9jaXR5WCwgaW1hZ2VzLmxlbmd0aCwgbmF2aWdhdGVUb0luZGV4XSlcblxuICAvLyBNb3VzZSBldmVudHMgZm9yIGRlc2t0b3AgdGVzdGluZ1xuICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHNldElzRHJhZ2dpbmcodHJ1ZSlcbiAgICBzZXRTdGFydFgoZS5jbGllbnRYKVxuICAgIHNldFN0YXJ0VGltZShEYXRlLm5vdygpKVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlZi5jdXJyZW50Py5vZmZzZXRXaWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNvbnN0IG9mZnNldCA9IGUuY2xpZW50WCAtIHN0YXJ0WFxuICAgIGNvbnN0IGN1cnJlbnRUYXJnZXRPZmZzZXQgPSAtaW5kZXggKiBjb250YWluZXJXaWR0aFxuXG4gICAgc2V0RHJhZ09mZnNldChjdXJyZW50VGFyZ2V0T2Zmc2V0ICsgb2Zmc2V0KVxuICB9LCBbaXNEcmFnZ2luZywgc3RhcnRYLCBpbmRleF0pXG5cbiAgY29uc3QgaGFuZGxlTW91c2VVcCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVmLmN1cnJlbnQ/Lm9mZnNldFdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgY29uc3QgZGVsdGFYID0gZHJhZ09mZnNldCArIChpbmRleCAqIGNvbnRhaW5lcldpZHRoKVxuXG4gICAgc2V0SXNEcmFnZ2luZyhmYWxzZSlcblxuICAgIGxldCBuZXdJbmRleCA9IGluZGV4XG4gICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBjb250YWluZXJXaWR0aCAqIFNOQVBfVEhSRVNIT0xEKSB7XG4gICAgICBpZiAoZGVsdGFYIDwgMCAmJiBpbmRleCA8IGltYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5ld0luZGV4ID0gaW5kZXggKyAxXG4gICAgICB9IGVsc2UgaWYgKGRlbHRhWCA+IDAgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgIG5ld0luZGV4ID0gaW5kZXggLSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgbmF2aWdhdGVUb0luZGV4KG5ld0luZGV4KVxuICB9LCBbaXNEcmFnZ2luZywgZHJhZ09mZnNldCwgaW5kZXgsIGltYWdlcy5sZW5ndGgsIG5hdmlnYXRlVG9JbmRleF0pXG5cbiAgLy8gQ2xlYW51cCBhbmltYXRpb24gb24gdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0aW9uXG4gIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2RyYWdPZmZzZXR9cHgsIDAsIDApYFxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGN1cnNvcjogaXNEcmFnZ2luZyA/ICdncmFiYmluZycgOiAnZ3JhYicsXG4gICAgICAgIHRvdWNoQWN0aW9uOiAncGFuLXknLFxuICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJ1xuICAgICAgfX1cbiAgICAgIG9uVG91Y2hTdGFydD17aGFuZGxlVG91Y2hTdGFydH1cbiAgICAgIG9uVG91Y2hNb3ZlPXtoYW5kbGVUb3VjaE1vdmV9XG4gICAgICBvblRvdWNoRW5kPXtoYW5kbGVUb3VjaEVuZH1cbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVNb3VzZURvd259XG4gICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgb25Nb3VzZVVwPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZVVwfVxuICAgID5cbiAgICAgIDxkaXYgXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIHdpZHRoOiBgJHtpbWFnZXMubGVuZ3RoICogMTAwfSVgLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBpc0RyYWdnaW5nID8gJ25vbmUnIDogJ3RyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScsXG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybScsXG4gICAgICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7aW1hZ2VzLm1hcCgodXJsLCBpbWdJbmRleCkgPT4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGtleT17aW1nSW5kZXh9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICB3aWR0aDogYCR7MTAwIC8gaW1hZ2VzLmxlbmd0aH0lYCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3JjPXt1cmx9XG4gICAgICAgICAgICAgIGFsdD17YCR7cG9zdD8udGl0bGUgfHwgJ1Bvc3QnfSAtICR7aW1nSW5kZXggKyAxfS8ke2ltYWdlcy5sZW5ndGh9YH1cbiAgICAgICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBvYmplY3RGaXQ6ICdjb250YWluJyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVaKDApJyxcbiAgICAgICAgICAgICAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC8vIFN1YnRsZSBwYXJhbGxheCBlZmZlY3QgZHVyaW5nIGRyYWdcbiAgICAgICAgICAgICAgICAuLi4oaXNEcmFnZ2luZyAmJiBpbWdJbmRleCAhPT0gaW5kZXggJiYge1xuICAgICAgICAgICAgICAgICAgZmlsdGVyOiAnYnJpZ2h0bmVzcygwLjgpJyxcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVooMCkgc2NhbGUoMC45NSknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9eyhlKSA9PiBlLnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogUHJvZ3Jlc3MgaW5kaWNhdG9ycyAqL31cbiAgICAgIHtpbWFnZXMubGVuZ3RoID4gMSAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBib3R0b206ICcyMHB4JyxcbiAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgZ2FwOiAnM3B4JyxcbiAgICAgICAgICB6SW5kZXg6IDIwXG4gICAgICAgIH19PlxuICAgICAgICAgIHtpbWFnZXMubWFwKChfLCBkb3RJbmRleCkgPT4gKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBrZXk9e2RvdEluZGV4fVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoZG90SW5kZXgpXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcycHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBkb3RJbmRleCA9PT0gaW5kZXggPyAnd2hpdGUnIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjJzIGVhc2Utb3V0JyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGRvdEluZGV4ID09PSBpbmRleCA/ICdzY2FsZSgxLjUpJyA6ICdzY2FsZSgxKScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBkb3RJbmRleCA9PT0gaW5kZXggPyAnMCAwIDRweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogJzEycHgnLFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodDogJzEycHgnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcidcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZCA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknXG4gICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIG9uTW91c2VPdXQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZCA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknXG4gICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMSknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJJbnN0YWdyYW1DYXJvdXNlbCIsImltYWdlcyIsImN1cnJlbnRJbmRleCIsIm9uSW5kZXhDaGFuZ2UiLCJwb3N0IiwiaW5kZXgiLCJzZXRJbmRleCIsImlzRHJhZ2dpbmciLCJzZXRJc0RyYWdnaW5nIiwiZHJhZ09mZnNldCIsInNldERyYWdPZmZzZXQiLCJzdGFydFgiLCJzZXRTdGFydFgiLCJzdGFydFRpbWUiLCJzZXRTdGFydFRpbWUiLCJ2ZWxvY2l0eVgiLCJzZXRWZWxvY2l0eVgiLCJjb250YWluZXJSZWYiLCJhbmltYXRpb25SZWYiLCJsYXN0VG91Y2hUaW1lIiwibGFzdFRvdWNoWCIsIlNOQVBfVEhSRVNIT0xEIiwiVkVMT0NJVFlfVEhSRVNIT0xEIiwiRlJJQ1RJT04iLCJTUFJJTkdfREFNUElORyIsIlNQUklOR19TVElGRk5FU1MiLCJhbmltYXRlVG9JbmRleCIsInRhcmdldEluZGV4IiwiaW5pdGlhbFZlbG9jaXR5IiwiY3VycmVudCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY29udGFpbmVyV2lkdGgiLCJvZmZzZXRXaWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJ0YXJnZXRPZmZzZXQiLCJjdXJyZW50T2Zmc2V0IiwidmVsb2NpdHkiLCJhbmltYXRlIiwiZGlzdGFuY2UiLCJzcHJpbmdGb3JjZSIsIk1hdGgiLCJhYnMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuYXZpZ2F0ZVRvSW5kZXgiLCJuZXdJbmRleCIsImNsYW1wZWRJbmRleCIsIm1heCIsIm1pbiIsImxlbmd0aCIsImhhbmRsZVRvdWNoU3RhcnQiLCJlIiwidG91Y2giLCJ0b3VjaGVzIiwiY2xpZW50WCIsIkRhdGUiLCJub3ciLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVUb3VjaE1vdmUiLCJjdXJyZW50VGltZSIsImRlbHRhVGltZSIsImRlbHRhWCIsImRlbHRhWSIsImNsaWVudFkiLCJyYXdPZmZzZXRYIiwicHJldmVudERlZmF1bHQiLCJyYXdPZmZzZXQiLCJvZmZzZXQiLCJjdXJyZW50VGFyZ2V0T2Zmc2V0IiwiaGFuZGxlVG91Y2hFbmQiLCJhYnNWZWxvY2l0eSIsIm1vbWVudHVtIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsInRyYW5zZm9ybSIsImRpdiIsInJlZiIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwiY3Vyc29yIiwidG91Y2hBY3Rpb24iLCJXZWJraXRVc2VyU2VsZWN0IiwidXNlclNlbGVjdCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJkaXNwbGF5IiwidHJhbnNpdGlvbiIsIndpbGxDaGFuZ2UiLCJiYWNrZmFjZVZpc2liaWxpdHkiLCJtYXAiLCJ1cmwiLCJpbWdJbmRleCIsImZsZXhTaHJpbmsiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJpbWciLCJzcmMiLCJhbHQiLCJ0aXRsZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0Iiwib2JqZWN0Rml0IiwiZmlsdGVyIiwib25EcmFnU3RhcnQiLCJib3R0b20iLCJsZWZ0IiwiZ2FwIiwiekluZGV4IiwiXyIsImRvdEluZGV4IiwiYnV0dG9uIiwib25DbGljayIsImJvcmRlclJhZGl1cyIsImJvcmRlciIsImJhY2tncm91bmQiLCJib3hTaGFkb3ciLCJXZWJraXRUYXBIaWdobGlnaHRDb2xvciIsIm91dGxpbmUiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm9uTW91c2VPdmVyIiwidGFyZ2V0Iiwib25Nb3VzZU91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/InstagramCarousel.js\n"));

/***/ })

});